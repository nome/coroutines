var search_data = {"index":{"searchIndex":["array","consumer","yielder","coroutineerror","enumerable","enumerator","lazy","hash","io","method","object","proc","sink","inputmapwrapper","inputreducewrapper","inputrejectwrapper","inputselectwrapper","inputwrapper","multicast","string","symbol","transformer","firstyielder","lazy","yielder","secondyielder","<<()","<<()","<<()","<<()","<<()","<<()","<<()","<<()","<<()","<=()","<=()","<=()","<=()",">=()",">=()",">=()",">=()","await()","await()","await()","await()","await()","bytes_transferred()","close()","close()","close()","close()","close()","collect()","collect_concat()","consum_for()","count()","define_yield()","drop()","drop_while()","dump()","each()","filter_map()","filter_map()","filter_map()","find_404()","flat_map()","follow()","in_connect()","in_connect()","inject()","input_map()","input_reduce()","input_reject()","input_select()","inspect()","inspect()","inspect()","inspect()","inspect()","lazy()","lazy()","map()","new()","new()","new()","new()","new()","new()","new()","new()","out_connect()","out_connect()","out_connect()","parse()","parse_dpkg_status()","reduce()","reject()","request_rate()","select()","sort()","sort_by()","take()","take_while()","to_a()","to_datetime()","to_h()","to_trans()","to_trans()","to_trans()","trans_for()","transformer_chain()","unwrap()","yield()","yield()","bsdl","copying","readme"],"longSearchIndex":["array","consumer","consumer::yielder","coroutineerror","enumerable","enumerator","enumerator::lazy","hash","io","method","object","proc","sink","sink::inputmapwrapper","sink::inputreducewrapper","sink::inputrejectwrapper","sink::inputselectwrapper","sink::inputwrapper","sink::multicast","string","symbol","transformer","transformer::firstyielder","transformer::lazy","transformer::lazy::yielder","transformer::secondyielder","consumer#<<()","hash#<<()","method#<<()","sink::inputmapwrapper#<<()","sink::inputreducewrapper#<<()","sink::inputrejectwrapper#<<()","sink::inputselectwrapper#<<()","sink::multicast#<<()","transformer::secondyielder#<<()","proc#<=()","sink#<=()","symbol#<=()","transformer#<=()","enumerable#>=()","proc#>=()","symbol#>=()","transformer#>=()","consumer::yielder#await()","object#await()","transformer::firstyielder#await()","transformer::lazy::yielder#await()","transformer::secondyielder#await()","object#bytes_transferred()","consumer#close()","sink#close()","sink::inputreducewrapper#close()","sink::inputwrapper#close()","sink::multicast#close()","transformer::lazy#collect()","transformer::lazy#collect_concat()","object#consum_for()","transformer::lazy#count()","transformer::lazy::yielder#define_yield()","transformer::lazy#drop()","transformer::lazy#drop_while()","object#dump()","transformer::lazy#each()","enumerable#filter_map()","enumerator::lazy#filter_map()","transformer::lazy#filter_map()","object#find_404()","transformer::lazy#flat_map()","object#follow()","sink#in_connect()","transformer#in_connect()","transformer::lazy#inject()","sink#input_map()","sink#input_reduce()","sink#input_reject()","sink#input_select()","consumer#inspect()","sink::inputmapwrapper#inspect()","sink::inputrejectwrapper#inspect()","sink::inputselectwrapper#inspect()","transformer#inspect()","transformer#lazy()","transformer::lazy#lazy()","transformer::lazy#map()","consumer::new()","sink::inputreducewrapper::new()","sink::inputwrapper::new()","sink::multicast::new()","transformer::new()","transformer::lazy::new()","transformer::lazy::yielder::new()","transformer::secondyielder::new()","enumerable#out_connect()","transformer#out_connect()","transformer::lazy#out_connect()","object#parse()","object#parse_dpkg_status()","transformer::lazy#reduce()","transformer::lazy#reject()","object#request_rate()","transformer::lazy#select()","transformer::lazy#sort()","transformer::lazy#sort_by()","transformer::lazy#take()","transformer::lazy#take_while()","transformer::lazy#to_a()","string#to_datetime()","transformer::lazy#to_h()","proc#to_trans()","symbol#to_trans()","transformer#to_trans()","object#trans_for()","transformer#transformer_chain()","object#unwrap()","transformer::firstyielder#yield()","transformer::secondyielder#yield()","","",""],"info":[["Array","","Array.html","",""],["Consumer","","Consumer.html","","<p>A class implementing consumer coroutines\n<p>A Consumer can be created by the following methods:\n<p>Object#consum_for …\n"],["Consumer::Yielder","","Consumer/Yielder.html","",""],["CoroutineError","","CoroutineError.html","",""],["Enumerable","","Enumerable.html","",""],["Enumerator","","Enumerator.html","",""],["Enumerator::Lazy","","Enumerator/Lazy.html","",""],["Hash","","Hash.html","",""],["IO","","IO.html","",""],["Method","","Method.html","",""],["Object","","Object.html","",""],["Proc","","Proc.html","",""],["Sink","","Sink.html","","<p>The <code>Sink</code> mixin provides classes that can accept streams of\nvalues with several utility methods. Classes …\n"],["Sink::InputMapWrapper","","Sink/InputMapWrapper.html","",""],["Sink::InputReduceWrapper","","Sink/InputReduceWrapper.html","",""],["Sink::InputRejectWrapper","","Sink/InputRejectWrapper.html","",""],["Sink::InputSelectWrapper","","Sink/InputSelectWrapper.html","",""],["Sink::InputWrapper","","Sink/InputWrapper.html","",""],["Sink::Multicast","","Sink/Multicast.html","","<p>Collects multiple sinks into a multicast group. Every input value of the\nmulticast group is supplied …\n"],["String","","String.html","","<p>Example shamelessly stolen from www.dabeaz.com/generators\n"],["Symbol","","Symbol.html","",""],["Transformer","","Transformer.html","","<p>A class implementing transformer coroutines\n<p>A Transformer can be created by the following methods:\n<p>Object#trans_for …\n"],["Transformer::FirstYielder","","Transformer/FirstYielder.html","",""],["Transformer::Lazy","","Transformer/Lazy.html","",""],["Transformer::Lazy::Yielder","","Transformer/Lazy/Yielder.html","",""],["Transformer::SecondYielder","","Transformer/SecondYielder.html","",""],["<<","Consumer","Consumer.html#method-i-3C-3C","(obj)","<p>Feeds <code>obj</code> as an input to the consumer.\n"],["<<","Hash","Hash.html#method-i-3C-3C","(args)","<p>Equivalent to hash = value, but allows chaining:\n\n<pre class=\"ruby\">{} <span class=\"ruby-operator\">&lt;&lt;</span> [<span class=\"ruby-value\">1</span>, <span class=\"ruby-string\">&quot;one&quot;</span>] <span class=\"ruby-operator\">&lt;&lt;</span> [<span class=\"ruby-value\">2</span>, <span class=\"ruby-string\">&quot;two&quot;</span>] <span class=\"ruby-operator\">&lt;&lt;</span> [<span class=\"ruby-value\">3</span>, <span class=\"ruby-string\">&quot;three&quot;</span>]  <span class=\"ruby-comment\">#=&gt; {1=&gt;&quot;one&quot;, ...</span>\n</pre>\n"],["<<","Method","Method.html#method-i-3C-3C","(args)","<p>Equivalent to method.call(arg1, arg2, …), but allows chaining:\n\n<pre>method(:puts) &lt;&lt; 1 &lt;&lt; 2 &lt;&lt; 3  # print ...</pre>\n"],["<<","Sink::InputMapWrapper","Sink/InputMapWrapper.html#method-i-3C-3C","(args)",""],["<<","Sink::InputReduceWrapper","Sink/InputReduceWrapper.html#method-i-3C-3C","(arg)",""],["<<","Sink::InputRejectWrapper","Sink/InputRejectWrapper.html#method-i-3C-3C","(args)",""],["<<","Sink::InputSelectWrapper","Sink/InputSelectWrapper.html#method-i-3C-3C","(args)",""],["<<","Sink::Multicast","Sink/Multicast.html#method-i-3C-3C","(obj)",""],["<<","Transformer::SecondYielder","Transformer/SecondYielder.html#method-i-3C-3C","(*args)",""],["<=","Proc","Proc.html#method-i-3C-3D","(source)","<p>Equivalent to proc.to_trans &lt;= trans/enum, except that it uses a more\nefficient implementation.\n"],["<=","Sink","Sink.html#method-i-3C-3D","(other)","<p>In the first form, iterate over <code>enum</code> and write each result to\n<code>sink</code> using &lt;&lt;; then return the result …\n"],["<=","Symbol","Symbol.html#method-i-3C-3D","(source)","<p>Equivalent to sym.to_trans &lt;= trans/enum, except that it uses a more\nefficient implementation.\n"],["<=","Transformer","Transformer.html#method-i-3C-3D","(source)",""],[">=","Enumerable","Enumerable.html#method-i-3E-3D","(other)","<p>In the first form, iterate over <code>enum</code> and write each result to\n<code>sink</code> using &lt;&lt;; then return the result …\n"],[">=","Proc","Proc.html#method-i-3E-3D","(sink)","<p>Equivalent to proc.to_trans &gt;= trans/sink, except that it uses a more\nefficient implementation.\n"],[">=","Symbol","Symbol.html#method-i-3E-3D","(sink)","<p>Equivalent to sym.to_trans &gt;= trans/sink, except that it uses a more\nefficient implementation.\n"],[">=","Transformer","Transformer.html#method-i-3E-3D","(sink)",""],["await","Consumer::Yielder","Consumer/Yielder.html#method-i-await","()",""],["await","Object","Object.html#method-i-await","()","<p>Evaluates to the next input value from the associated consumption context.\nIn order to create a consumption …\n"],["await","Transformer::FirstYielder","Transformer/FirstYielder.html#method-i-await","()",""],["await","Transformer::Lazy::Yielder","Transformer/Lazy/Yielder.html#method-i-await","()",""],["await","Transformer::SecondYielder","Transformer/SecondYielder.html#method-i-await","()",""],["bytes_transferred","Object","Object.html#method-i-bytes_transferred","()",""],["close","Consumer","Consumer.html#method-i-close","()","<p>Terminate the consumer by raising StopIteration at the point where it last\nrequested an input value. …\n"],["close","Sink","Sink.html#method-i-close","()","<p>May be overriden by classes using the Sink mixin. The default\nimplementation just returns self.\n"],["close","Sink::InputReduceWrapper","Sink/InputReduceWrapper.html#method-i-close","()",""],["close","Sink::InputWrapper","Sink/InputWrapper.html#method-i-close","()",""],["close","Sink::Multicast","Sink/Multicast.html#method-i-close","()",""],["collect","Transformer::Lazy","Transformer/Lazy.html#method-i-collect","(&block)",""],["collect_concat","Transformer::Lazy","Transformer/Lazy.html#method-i-collect_concat","(&block)",""],["consum_for","Object","Object.html#method-i-consum_for","(meth, *args)","<p>Creates a new Consumer coroutine from the given method. This is analogous\nto using Kernel#enum_for to …\n"],["count","Transformer::Lazy","Transformer/Lazy.html#method-i-count","()",""],["define_yield","Transformer::Lazy::Yielder","Transformer/Lazy/Yielder.html#method-i-define_yield","(&block)",""],["drop","Transformer::Lazy","Transformer/Lazy.html#method-i-drop","(n)",""],["drop_while","Transformer::Lazy","Transformer/Lazy.html#method-i-drop_while","(&block)",""],["dump","Object","Object.html#method-i-dump","(label)",""],["each","Transformer::Lazy","Transformer/Lazy.html#method-i-each","(&block)",""],["filter_map","Enumerable","Enumerable.html#method-i-filter_map","(&block)","<p>For each <code>obj</code> in in <code>enum</code>, calls\n<code>block</code>, and collects its non-nil return values into a new\n<code>array</code>.\n"],["filter_map","Enumerator::Lazy","Enumerator/Lazy.html#method-i-filter_map","()","<p>Returns a new lazy Enumerator which iterates over all non-nil values\nreturned by <code>block</code> while <code>obj</code> iterates …\n"],["filter_map","Transformer::Lazy","Transformer/Lazy.html#method-i-filter_map","(&block)",""],["find_404","Object","Object.html#method-i-find_404","()","<p>Reads log entry Hashes; for each log entry with status 404, yields\n"],["flat_map","Transformer::Lazy","Transformer/Lazy.html#method-i-flat_map","(&block)",""],["follow","Object","Object.html#method-i-follow","(path)",""],["in_connect","Sink","Sink.html#method-i-in_connect","(other)","<p>In the first form, iterate over <code>enum</code> and write each result to\n<code>sink</code> using &lt;&lt;; then return the result …\n"],["in_connect","Transformer","Transformer.html#method-i-in_connect","(source)","<p>In the first form, creates a new Transformer that has the input of\n<code>trans</code> connected to the output of  …\n"],["inject","Transformer::Lazy","Transformer/Lazy.html#method-i-inject","(*args)",""],["input_map","Sink","Sink.html#method-i-input_map","(&block)","<p>Returns a new sink which supplies each of its input values to the given\nblock and feeds each result of …\n"],["input_reduce","Sink","Sink.html#method-i-input_reduce","(*args, &block)","<p>Returns a new sink which reduces its input values to a single value, as in\nEnumerable#reduce.  When  …\n"],["input_reject","Sink","Sink.html#method-i-input_reject","(&block)","<p>Returns a new sink which feeds those inputs for which <code>block</code>\nreturns a false value to <code>sink</code> and discards …\n"],["input_select","Sink","Sink.html#method-i-input_select","()","<p>Returns a new sink which feeds those inputs for which <code>block</code>\nreturns a true value to <code>sink</code> and discards …\n"],["inspect","Consumer","Consumer.html#method-i-inspect","()",""],["inspect","Sink::InputMapWrapper","Sink/InputMapWrapper.html#method-i-inspect","()",""],["inspect","Sink::InputRejectWrapper","Sink/InputRejectWrapper.html#method-i-inspect","()",""],["inspect","Sink::InputSelectWrapper","Sink/InputSelectWrapper.html#method-i-inspect","()",""],["inspect","Transformer","Transformer.html#method-i-inspect","()",""],["lazy","Transformer","Transformer.html#method-i-lazy","()","<p>Returns a “lazy enumeration like” transformer. More precisely, the object\nreturned can in many …\n"],["lazy","Transformer::Lazy","Transformer/Lazy.html#method-i-lazy","()",""],["map","Transformer::Lazy","Transformer/Lazy.html#method-i-map","(&block)",""],["new","Consumer","Consumer.html#method-c-new","(&block)","<p>Creates a new Consumer coroutine, which can be used as a Sink.\n<p>The block is called immediately with a …\n"],["new","Sink::InputReduceWrapper","Sink/InputReduceWrapper.html#method-c-new","(target, initial=nil, &block)",""],["new","Sink::InputWrapper","Sink/InputWrapper.html#method-c-new","(target, &block)",""],["new","Sink::Multicast","Sink/Multicast.html#method-c-new","(*receivers)",""],["new","Transformer","Transformer.html#method-c-new","(&block)","<p>Creates a new Transformer coroutine defined by the given block.\n<p>The block is called with a “yielder” …\n"],["new","Transformer::Lazy","Transformer/Lazy.html#method-c-new","(trans)",""],["new","Transformer::Lazy::Yielder","Transformer/Lazy/Yielder.html#method-c-new","(wrapped)",""],["new","Transformer::SecondYielder","Transformer/SecondYielder.html#method-c-new","(y, fiber)",""],["out_connect","Enumerable","Enumerable.html#method-i-out_connect","(other)","<p>In the first form, iterate over <code>enum</code> and write each result to\n<code>sink</code> using &lt;&lt;; then return the result …\n"],["out_connect","Transformer","Transformer.html#method-i-out_connect","(sink)","<p>In the first form, creates a new Transformer that has the output of\n<code>trans</code> connected to the input of  …\n"],["out_connect","Transformer::Lazy","Transformer/Lazy.html#method-i-out_connect","(other)",""],["parse","Object","Object.html#method-i-parse","()","<p>Reads log lines in the following format: host referrer user [timestamp]\n“GET|POST request protocol” …\n"],["parse_dpkg_status","Object","Object.html#method-i-parse_dpkg_status","()","<p>Transformer that accepts lines of text and\n<p>appends any lines starting with a space to the previous line …\n"],["reduce","Transformer::Lazy","Transformer/Lazy.html#method-i-reduce","(*args)",""],["reject","Transformer::Lazy","Transformer/Lazy.html#method-i-reject","(&block)",""],["request_rate","Object","Object.html#method-i-request_rate","()",""],["select","Transformer::Lazy","Transformer/Lazy.html#method-i-select","(&block)",""],["sort","Transformer::Lazy","Transformer/Lazy.html#method-i-sort","()",""],["sort_by","Transformer::Lazy","Transformer/Lazy.html#method-i-sort_by","(&block)",""],["take","Transformer::Lazy","Transformer/Lazy.html#method-i-take","(n)",""],["take_while","Transformer::Lazy","Transformer/Lazy.html#method-i-take_while","(&block)",""],["to_a","Transformer::Lazy","Transformer/Lazy.html#method-i-to_a","()",""],["to_datetime","String","String.html#method-i-to_datetime","()","<p>parse Apache timestamps\n"],["to_h","Transformer::Lazy","Transformer/Lazy.html#method-i-to_h","()",""],["to_trans","Proc","Proc.html#method-i-to_trans","()","<p>Allows implicit conversion of Proc to Transformer. The transformer is a\ncombination of map and filter …\n"],["to_trans","Symbol","Symbol.html#method-i-to_trans","()","<p>Allows implicit conversion of Symbol to Transformer. The transformer\naccepts any objects as input, calls …\n"],["to_trans","Transformer","Transformer.html#method-i-to_trans","()","<p>Returns self.\n"],["trans_for","Object","Object.html#method-i-trans_for","(meth, *args)","<p>Creates a new Transformer instance that wraps the given method. This is\nanalogous to using Kernel#enum_for …\n"],["transformer_chain","Transformer","Transformer.html#method-i-transformer_chain","(other)",""],["unwrap","Object","Object.html#method-i-unwrap","(header=0x61, footer=0x62, escape=0xAB)","<p>Example shamelessly stolen from\neli.thegreenplace.net/2009/08/29/co-routines-as-an-alternative-to-state-machines\n…\n"],["yield","Transformer::FirstYielder","Transformer/FirstYielder.html#method-i-yield","(*args)",""],["yield","Transformer::SecondYielder","Transformer/SecondYielder.html#method-i-yield","(*args)",""],["BSDL","","BSDL.html","","<p>Copyright (C) 2014 Knut Franke. All rights reserved.\n<p>Redistribution and use in source and binary forms, …\n"],["COPYING","","COPYING.html","","<p>coroutines is copyrighted free software by Knut Franke\n&lt;Knut.Franke@gmx.de&gt;. You can redistribute …\n"],["README","","README_rdoc.html","","<p>Coroutines for Ruby\n<p>A library for creating and composing producer/transformer/consumer\ncoroutines. Producers …\n"]]}}